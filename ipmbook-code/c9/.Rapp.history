## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
## Use the Monocarp IBM with individual variation in flowering intercept to illustrate evolutionary dynamics#
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
#
rm(list=ls(all=TRUE))#
#
library(doBy)#
set.seed(53241986)#
#
## Working directory must be set here, so the source()'s below run#
setwd("~/Dropbox/Evol Demog/R code")#
#
source("Monocarp Demog Funs.R");#
source("Standard Graphical Pars.R");#
#
source("VarDynamics Funs.R"); #
#
# Set simulation parameters#
init.pop.size <- 10000#
Recr <- 7500#
#
n.yrs <- 500#
beta.off.sd <- 0.5#
init.beta.sd <- 0.7#
#
#  This generates the simulation data, it takes a while so we use #
#  a saved version#
load("SimData.Rdata")#
#
#load("SimDataSmallVar.Rdata")#
########### Run the IBM simulation #
if(FALSE) {#
  mean.flow.ints <- matrix(NA,nrow=n.yrs,ncol=10)#
  var.flow.ints <- matrix(NA,nrow=n.yrs,ncol=10)#
  min.z <- rep(NA,10)#
  max.z <- rep(NA,10)#
  min.beta <- rep(NA,10)#
  max.beta <- rep(NA,10)#
  for(reps in 1:10){#
     init.mean.flow.int <- ifelse(reps<6, -20, -30)#
	 source("Monocarp Simulate Evol IBM.R") #
     mean.flow.ints[,reps] <- mean.flow.int#
     var.flow.ints[,reps] <- var.flow.int#
     min.z[reps] <- min.z.t#
     max.z[reps] <- max.z.t#
     min.beta[reps] <- min.flow.int#
     max.beta[reps] <- max.flow.int#
     cat(reps,"   ",init.mean.flow.int,"\n")#
  }#
#
save(mean.flow.ints,var.flow.ints,min.z,max.z,min.beta,max.beta,#
n.yrs,beta.off.sd,init.beta.sd,file="SimData.Rdata")#
#
}#
########################################################################### #
# FIRST PLOT: IBM mean and variance of flowering intercept over time, 10 reps. #
############################################################################
#
graphics.off(); dev.new(); #
set_graph_pars("panel4"); #
matplot(mean.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
	ylab=expression(bar(beta)[0]),xlim=c(0,n.yrs))#
add_panel_label("a")#
matplot(var.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
ylab=expression("Var("* beta[0] *")"),xlim=c(0,n.yrs))#
add_panel_label("b")
nBigMatrix.z <- 100; #
nBigMatrix.beta <- 100; #
#
#######################  solve beta(0) = -20 first#
U.beta <- max(max.beta[1:5]) +  1 #
U.beta <- -10#
L.beta <-  min(min.beta[1:5]) - 1#
L.beta <- -30#
h.beta <- (U.beta - L.beta)/nBigMatrix.beta #
meshpts.beta20 <- L.beta + ((1:nBigMatrix.beta) - 1/2) * h.beta#
#
U.z <- max(max.z[1:5]) + 0.5 #
L.z <- min(min.z[1:5]) - 0.5 #
h.z <- (U.z - L.z)/nBigMatrix.z#
meshpts.z20 <- L.z + ((1:nBigMatrix.z) - 1/2) * h.z#
#
#nt each column is the density of z for a given flowering intercept#
sol.2D.minus20 <- iterate_model(m.par.true,n.yrs,-20,init.beta.sd,meshpts.beta20,meshpts.z20)#
#
########################   solve beta(0) = -30 next#
U.beta <- max(max.beta[6:10]) +  1 #
U.beta <- -20#
L.beta <-  min(min.beta[6:10]) - 1#
L.beta <- -40#
h.beta <- (U.beta - L.beta)/nBigMatrix.beta #
meshpts.beta30 <- L.beta + ((1:nBigMatrix.beta) - 1/2) * h.beta#
#
U.z <- max(max.z[6:10]) + 0.5 #
L.z <- min(min.z[6:10]) - 0.5 #
h.z <- (U.z - L.z)/nBigMatrix.z#
meshpts.z30 <- L.z + ((1:nBigMatrix.z) - 1/2) * h.z#
#
#nt each column is the density of z for a given flowering intercept#
sol.2D.minus30 <- iterate_model(m.par.true,n.yrs,-30,init.beta.sd,meshpts.beta30,meshpts.z30)#
#
## plot beta distributions over time #
beta20 <- sol.2D.minus20$betaDist;#
matplot(meshpts.beta20,beta20[,c(1,100,300,500)], xlab="Beta", ylab="Relative Frequency",type="l"); #
#
beta30 <- sol.2D.minus30$betaDist;#
matplot(meshpts.beta30,beta30[,c(1,100,300,500)], xlab="Beta", ylab="Relative Frequency",type="l"); #
######################### END FIRST PLOT #
#
##################################################################
#  SECOND PLOT #
#  Compare IBM to IPM; compare IPM to Gaussian moment-closure #
###################################################################
dev.new(); #
set_graph_pars("panel4"); #
matplot(mean.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
ylab="Mean flowering intercept",xlim=c(0,n.yrs))#
points(1:n.yrs,sol.2D.minus20$mean.beta,col="blue",type="l",lwd=2)#
points(1:n.yrs,sol.2D.minus30$mean.beta,col="turquoise",type="l",lwd=2)#
abline(h=-24.92462,col="red")#
legend("topright",legend=c("IBM -20","IBM -30", "IPM -20", "IPM -30"),#
	col=c("black","grey","blue","turquoise"),lty=1,lwd=2,bty="n");  #
#
add_panel_label("a")#
#
matplot(var.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
ylab="Variance flowering intercept",,xlim=c(0,n.yrs))#
points(1:n.yrs,sol.2D.minus20$var.beta,col="blue",type="l",lwd=2)#
points(1:n.yrs,sol.2D.minus30$var.beta,col="turquoise",type="l",lwd=2)#
add_panel_label("b")
maxbeta2 <- 1.1*max(sol.2D.minus20$mean.beta2,sol.2D.minus30$mean.beta2)#
#
plot(1:n.yrs,sol.2D.minus20$mean.beta2,ylim=c(0,maxbeta2),col="blue",type="l",lwd=2,ylab="Mean of beta^2")#
points(1:n.yrs,sol.2D.minus30$mean.beta2,col="turquoise",type="l",lwd=2)#
add_panel_label("c")#
#
#calculate variance of S assuming Gaussian distribution#
minus20.var <- sol.2D.minus20$mean.beta^4 + 6*(sol.2D.minus20$mean.beta^2)*sol.2D.minus20$var.beta +#
                 3*sol.2D.minus20$var.beta^2 - sol.2D.minus20$mean.beta2^2#
#
minus30.var <- sol.2D.minus30$mean.beta^4 + 6*(sol.2D.minus30$mean.beta^2)*sol.2D.minus30$var.beta +#
                 3*sol.2D.minus30$var.beta^2 - sol.2D.minus30$mean.beta2^2#
#
maxvarbeta2 <- 1.1 * max(sol.2D.minus20$var.beta2,sol.2D.minus30$var.beta2)#
#
plot(1:n.yrs,sol.2D.minus20$var.beta2,ylim=c(0,maxvarbeta2 ),col="blue",type="l",lwd=4,ylab="Variance of beta^2")#
points(1:n.yrs,minus20.var,col="red",type="l",lty=2)  # Gaussian approx #
#
points(1:n.yrs,sol.2D.minus30$var.beta2,col="turquoise",type="l",lwd=4)#
points(1:n.yrs,minus30.var,col="red",type="l",lty=2) # Gaussian approx #
add_panel_label("d")#
#
minus20.dvar <- 4*(sol.2D.minus20$mean.beta^2)*sol.2D.minus20$var.beta; #
minus30.dvar <- 4*(sol.2D.minus30$mean.beta^2)*sol.2D.minus30$var.beta; #
matpoints(1:n.yrs,cbind(minus20.dvar,minus30.dvar),type="l",lty=3,col="purple")#
legend("topright", c("Gaussian Approx","delta method"), lty=2,col=c("red","purple"),bty="n");
#the Gaussian assumption looks pretty good #
#
dev.new(); #
set_graph_pars("panel2"); #
plot(1:n.yrs,sol.2D.minus20$beta3,ylim=c(-1,1),col="turquoise",type="l",lwd=2,ylab="3rd central moment")#
points(1:n.yrs,sol.2D.minus30$beta3,col="blue",type="l",lwd=2)#
abline(h=0,col="red")#
#
plot(1:n.yrs,sol.2D.minus20$beta4-3*sol.2D.minus20$var.beta*sol.2D.minus20$var.beta,col="turquoise", type="l",lwd=2,ylab=" Deviation from Gaussian",ylim=c(-2,1))#
points(1:n.yrs,sol.2D.minus30$beta4-3*sol.2D.minus30$var.beta*sol.2D.minus30$var.beta,col="blue",type="l",lwd=2)#
abline(h=0,col="red")
######################################################################################
# FOURTH PLOT: NEW VARIANCE APPROX#
######################################################################################
nBigMatrix <- nBigMatrix.z; #
#
#First Approximate mean with var from 2D IPM#
#
### params,init.mean.flow.int,n.iter,delta,var.beta.t,prop.Recr#
beta.minus20 <- Approx_dynamics_Mean(m.par.true,-20,n.yrs,0.00001,sol.2D.minus30$var.beta)#
beta.minus30 <- Approx_dynamics_Mean(m.par.true,-30,n.yrs,0.00001,sol.2D.minus30$var.beta)#
#
#quick test the skew term is really small#
year.test <- 20#
#
mean.beta <- sum(meshpts.beta20*beta20[,year.test ])#
var.beta <- sum((meshpts.beta20-mean.beta)^2*beta20[,year.test ])#
skew.beta <- sum((meshpts.beta20-mean.beta)^3*beta20[,year.test ])#
#
beta.minus20$dlam[year.test ] * var.beta#
beta.minus20$d2.lambda.d.beta2[year.test ] * skew.beta#
#
#it is as expected#
#
#quick check it all adds up - sum of terms in equ 28 (RHS) should equal lambda sensitivity#
set_graph_pars("panel2");#
#
sum.t <- beta.minus20$change.P.w+beta.minus20$change.F.w +beta.minus20$P.change.w+beta.minus20$F.change.w#
plot(beta.minus20$dlam,sum.t)#
#
cor.test(beta.minus20$dlam,sum.t)#
max(abs(beta.minus20$dlam-sum.t),na.rm=TRUE)#
#
sum.t <- beta.minus30$change.P.w+beta.minus30$change.F.w +beta.minus30$P.change.w+beta.minus30$F.change.w#
plot(beta.minus30$dlam,sum.t)#
#
cor.test(beta.minus30$dlam,sum.t)#
max(abs(beta.minus30$dlam-sum.t),na.rm=TRUE)#
#
#looks OK#
#
#plot mean approx (equ 18) against 2-dimensional IPM and IBM#
#
dev.new(height=4,width=8); ### start plot #
set_graph_pars("panel2"); #
matplot(mean.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
	ylab="Mean beta",xlim=c(1,n.yrs)) #
points(1:n.yrs,sol.2D.minus20$mean.beta,col="blue",type="l",lty=1,lwd=4)#
points(1:n.yrs,sol.2D.minus30$mean.beta,col="turquoise",type="l",lty=1,lwd=4)#
points(1:n.yrs,beta.minus20$beta.t.mean,col="red",type="l",lty=2,lwd=2)#
points(1:n.yrs,beta.minus30$beta.t.mean,col="red",type="l",lty=2,lwd=2)#
legend("topright",legend=c("IPM -20","IPM -30","Approx"),col=c("blue","turquoise","red"),#
    lty=1,bty="n",lwd=c(3,3,2));  #
#
add_panel_label("a")#
#
#plot 2-dimensional IPM variance and IBM#
#
matplot(var.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
	ylab="Variance beta",xlim=c(1,n.yrs))#
points(1:n.yrs,sol.2D.minus20$var.beta,col="blue",type="l",lwd=3)#
points(1:n.yrs,sol.2D.minus30$var.beta,col="turquoise",type="l",lwd=3)#
#
points(1:n.yrs,beta.minus20$beta.t.var,col="purple",type="l",lwd=2,lty=2)#
points(1:n.yrs,beta.minus30$beta.t.var,col="red",type="l",lwd=2,lty=2)#
add_panel_label("b")#
#
#plot recruitment - survival decompostion (equ 27)#
#
dev.new(height=4,width=8);#
set_graph_pars("panel2"); #
#
plot(1:n.yrs,beta.minus20$dlam,type="l",ylim=c(-0.02,0.03),lwd=2,xlab="Time",#
	ylab="Selection")#
points(1:n.yrs,beta.minus20$dsurv,col="red",type="l")#
points(1:n.yrs,beta.minus20$dfec,col="turquoise",type="l")#
abline(h=0)#
#
legend("topright",legend=c("Total","Surv","Rec"),col=c("black","red","turquoise"),#
    lty=1,bty="n",lwd=c(2,1,1),cex=0.75)#
add_panel_label("a")#
#
plot(1:n.yrs,beta.minus30$dlam,type="l",ylim=c(-0.02,0.03),lwd=2,xlab="Time",#
	ylab="Selection")#
points(1:n.yrs,beta.minus30$dsurv,col="red",type="l")#
points(1:n.yrs,beta.minus30$dfec,col="turquoise",type="l")#
abline(h=0)#
#
legend("topright",legend=c("Total","Surv","Rec"),col=c("black","red","turquoise"),#
    lty=1,bty="n",lwd=c(2,1,1),cex=0.75)#
add_panel_label("b")
dev.new(height=4,width=8);#
set_graph_pars("panel2"); #
#
plot(1:n.yrs,beta.minus20$dlam,type="l",ylim=c(-0.15,0.15),lwd=2,xlab="Time",#
	ylab="Selection")#
points(1:n.yrs,beta.minus20$change.P.w+beta.minus20$change.F.w,col="red",type="l")#
points(1:n.yrs,beta.minus20$P.change.w+beta.minus20$F.change.w,col="turquoise",type="l")#
abline(h=0)#
add_panel_label("a")#
legend("topright",legend=c("Total",expression(partialdiff*(F+P)*w),expression((F+P)*partialdiff*w)),col=c("black","red","turquoise"),#
    lty=1,bty="n",lwd=c(2,1,1),cex=0.75)#
 plot(1:n.yrs,beta.minus30$dlam,type="l",ylim=c(-0.15,0.15),lwd=2,xlab="Time",#
	ylab="Selection")#
points(1:n.yrs,beta.minus30$change.P.w+beta.minus30$change.F.w,col="red",type="l")#
points(1:n.yrs,beta.minus30$P.change.w+beta.minus30$F.change.w,col="turquoise",type="l")#
abline(h=0)#
#
add_panel_label("b")#
#
legend("topright",legend=c("Total",expression(partialdiff*(F+P)*w),expression((F+P)*partialdiff*w)),col=c("black","red","turquoise"),#
    lty=1,bty="n",lwd=c(2,1,1),cex=0.75)
#plot all 4 terms from the decomposition equ 28   #
dev.new(height=4,width=8);#
set_graph_pars("panel2"); #
#
plot(1:n.yrs,beta.minus20$dlam,type="l",ylim=c(-0.15,0.2),lwd=2,xlab="Time",#
	ylab="Selection")#
points(1:n.yrs,beta.minus20$change.P.w,col="red",type="l",lwd=2)#
points(1:n.yrs,beta.minus20$change.F.w,col="turquoise",type="l",lwd=2)#
points(1:n.yrs,beta.minus20$P.change.w,col="red",type="l",lty=2)#
points(1:n.yrs,beta.minus20$F.change.w,col="turquoise",type="l",lty=2)#
abline(h=0)#
#
legend("topright", legend=c("Total",expression(partialdiff*P*w),expression(partialdiff*F*w),#
expression(P*partialdiff*w),expression(F*partialdiff*w)),col=c("black","red","turquoise","red","turquoise"),#
    lty=c(1,1,1,2,2),,bty="n",lwd=c(2,2,2,1,1),cex=0.5)#
#
add_panel_label("a")#
 plot(1:n.yrs,beta.minus30$dlam,type="l",ylim=c(-0.15,0.2),lwd=2,xlab="Time",#
	ylab="Selection")#
points(1:n.yrs,beta.minus30$change.P.w,col="red",type="l",lwd=2)#
points(1:n.yrs,beta.minus30$change.F.w,col="turquoise",type="l",lwd=2)#
points(1:n.yrs,beta.minus30$P.change.w,col="red",type="l",lty=2)#
points(1:n.yrs,beta.minus30$F.change.w,col="turquoise",type="l",lty=2)#
abline(h=0)#
#
legend("topright", legend=c("Total",expression(partialdiff*P*w),expression(partialdiff*F*w),#
expression(P*partialdiff*w),expression(F*partialdiff*w)),col=c("black","red","turquoise","red","turquoise"),#
    lty=c(1,1,1,2,2),bty="n",lwd=c(2,2,2,1,1),cex=0.5)
add_panel_label("b")
#Approximate mean and variance dynamics - NO cheating!#
#
beta.minus20.var <- Approx_dynamics_Var(m.par.true,-20,n.yrs,0.01,sol.2D.minus20$zDist)#
beta.minus30.var <- Approx_dynamics_Var(m.par.true,-30,n.yrs,0.01,sol.2D.minus30$zDist)#
#
#plot mean and variance dynamics from closed approximation (equ 18-20)#
#
dev.new(height=4,width=8); ### start plot #
set_graph_pars("panel2"); #
matplot(mean.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
	ylab=expression(bar(beta)[0]),xlim=c(1,n.yrs)) #
points(1:n.yrs,sol.2D.minus20$mean.beta,col="blue",type="l",lty=1,lwd=4)#
points(1:n.yrs,sol.2D.minus30$mean.beta,col="turquoise",type="l",lty=1,lwd=4)#
points(1:n.yrs,beta.minus20.var$beta.t.mean,col="red",type="l",lty=2,lwd=2)#
points(1:n.yrs,beta.minus30.var$beta.t.mean,col="red",type="l",lty=2,lwd=2)#
legend("topright",legend=c("IPM -20","IPM -30","Approx"),col=c("blue","turquoise","red"),#
    lty=c(1,1,2),bty="n",lwd=c(3,3,2));  #
#
add_panel_label("a")#
 matplot(var.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
	ylab=expression("Var("* beta[0] *")"),xlim=c(1,n.yrs),ylim=c(0,7))#
points(1:n.yrs,sol.2D.minus20$var.beta,col="blue",type="l",lwd=3)#
points(1:n.yrs,sol.2D.minus30$var.beta,col="turquoise",type="l",lwd=3)#
#
points(1:n.yrs,beta.minus20.var$beta.t.var,col="red",type="l",lwd=2,lty=2)#
points(1:n.yrs,beta.minus30.var$beta.t.var,col="red",type="l",lwd=2,lty=2)#
add_panel_label("b")
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
## Use the Monocarp IBM with individual variation in flowering intercept to illustrate evolutionary dynamics#
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
#
rm(list=ls(all=TRUE))#
#
library(doBy)#
set.seed(53241986)#
#
## Working directory must be set here, so the source()'s below run#
setwd("~/Dropbox/Evol Demog/R code")#
#
source("Monocarp Demog Funs.R");#
source("Standard Graphical Pars.R");#
#
source("VarDynamics Funs.R"); #
#
# Set simulation parameters#
init.pop.size <- 10000#
Recr <- 7500#
#
n.yrs <- 500#
beta.off.sd <- 0.5#
init.beta.sd <- 0.7#
#
#  This generates the simulation data, it takes a while so we use #
#  a saved version#
load("SimData.Rdata")#
#
#load("SimDataSmallVar.Rdata")#
########### Run the IBM simulation #
if(FALSE) {#
  mean.flow.ints <- matrix(NA,nrow=n.yrs,ncol=10)#
  var.flow.ints <- matrix(NA,nrow=n.yrs,ncol=10)#
  min.z <- rep(NA,10)#
  max.z <- rep(NA,10)#
  min.beta <- rep(NA,10)#
  max.beta <- rep(NA,10)#
  for(reps in 1:10){#
     init.mean.flow.int <- ifelse(reps<6, -20, -30)#
	 source("Monocarp Simulate Evol IBM.R") #
     mean.flow.ints[,reps] <- mean.flow.int#
     var.flow.ints[,reps] <- var.flow.int#
     min.z[reps] <- min.z.t#
     max.z[reps] <- max.z.t#
     min.beta[reps] <- min.flow.int#
     max.beta[reps] <- max.flow.int#
     cat(reps,"   ",init.mean.flow.int,"\n")#
  }#
#
save(mean.flow.ints,var.flow.ints,min.z,max.z,min.beta,max.beta,#
n.yrs,beta.off.sd,init.beta.sd,file="SimData.Rdata")#
#
}#
########################################################################### #
# FIRST PLOT: IBM mean and variance of flowering intercept over time, 10 reps. #
############################################################################
#
graphics.off(); dev.new(); #
set_graph_pars("panel4"); #
matplot(mean.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
	ylab=expression(bar(beta)[0]),xlim=c(0,n.yrs))#
add_panel_label("a")#
matplot(var.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
ylab=expression("Var("* beta[0] *")"),xlim=c(0,n.yrs))#
add_panel_label("b")#
#dev.copy2eps(file="~/Dropbox/Evol demog/figures/IBMs.eps")#
#
nBigMatrix.z <- 100; #
nBigMatrix.beta <- 100; #
#
#######################  solve beta(0) = -20 first#
U.beta <- max(max.beta[1:5]) +  1 #
U.beta <- -10#
L.beta <-  min(min.beta[1:5]) - 1#
L.beta <- -30#
h.beta <- (U.beta - L.beta)/nBigMatrix.beta #
meshpts.beta20 <- L.beta + ((1:nBigMatrix.beta) - 1/2) * h.beta#
#
U.z <- max(max.z[1:5]) + 0.5 #
L.z <- min(min.z[1:5]) - 0.5 #
h.z <- (U.z - L.z)/nBigMatrix.z#
meshpts.z20 <- L.z + ((1:nBigMatrix.z) - 1/2) * h.z#
#
#nt each column is the density of z for a given flowering intercept#
sol.2D.minus20 <- iterate_model(m.par.true,n.yrs,-20,init.beta.sd,meshpts.beta20,meshpts.z20)#
#
########################   solve beta(0) = -30 next#
U.beta <- max(max.beta[6:10]) +  1 #
U.beta <- -20#
L.beta <-  min(min.beta[6:10]) - 1#
L.beta <- -40#
h.beta <- (U.beta - L.beta)/nBigMatrix.beta #
meshpts.beta30 <- L.beta + ((1:nBigMatrix.beta) - 1/2) * h.beta#
#
U.z <- max(max.z[6:10]) + 0.5 #
L.z <- min(min.z[6:10]) - 0.5 #
h.z <- (U.z - L.z)/nBigMatrix.z#
meshpts.z30 <- L.z + ((1:nBigMatrix.z) - 1/2) * h.z#
#
#nt each column is the density of z for a given flowering intercept#
sol.2D.minus30 <- iterate_model(m.par.true,n.yrs,-30,init.beta.sd,meshpts.beta30,meshpts.z30)#
#
## plot beta distributions over time #
beta20 <- sol.2D.minus20$betaDist;#
matplot(meshpts.beta20,beta20[,c(1,100,300,500)], xlab="Beta", ylab="Relative Frequency",type="l"); #
#
beta30 <- sol.2D.minus30$betaDist;#
matplot(meshpts.beta30,beta30[,c(1,100,300,500)], xlab="Beta", ylab="Relative Frequency",type="l"); #
######################### END FIRST PLOT #
#
##################################################################
#  SECOND PLOT #
#  Compare IBM to IPM; compare IPM to Gaussian moment-closure #
###################################################################
dev.new(); #
set_graph_pars("panel4"); #
matplot(mean.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
ylab="Mean flowering intercept",xlim=c(0,n.yrs))#
points(1:n.yrs,sol.2D.minus20$mean.beta,col="blue",type="l",lwd=2)#
points(1:n.yrs,sol.2D.minus30$mean.beta,col="turquoise",type="l",lwd=2)#
abline(h=-24.92462,col="red")#
legend("topright",legend=c("IBM -20","IBM -30", "IPM -20", "IPM -30"),#
	col=c("black","grey","blue","turquoise"),lty=1,lwd=2,bty="n");  #
#
add_panel_label("a")#
#
matplot(var.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
ylab="Variance flowering intercept",,xlim=c(0,n.yrs))#
points(1:n.yrs,sol.2D.minus20$var.beta,col="blue",type="l",lwd=2)#
points(1:n.yrs,sol.2D.minus30$var.beta,col="turquoise",type="l",lwd=2)#
add_panel_label("b")#
#
maxbeta2 <- 1.1*max(sol.2D.minus20$mean.beta2,sol.2D.minus30$mean.beta2)#
#
plot(1:n.yrs,sol.2D.minus20$mean.beta2,ylim=c(0,maxbeta2),col="blue",type="l",lwd=2,ylab="Mean of beta^2")#
points(1:n.yrs,sol.2D.minus30$mean.beta2,col="turquoise",type="l",lwd=2)#
add_panel_label("c")#
#
#calculate variance of S assuming Gaussian distribution#
minus20.var <- sol.2D.minus20$mean.beta^4 + 6*(sol.2D.minus20$mean.beta^2)*sol.2D.minus20$var.beta +#
                 3*sol.2D.minus20$var.beta^2 - sol.2D.minus20$mean.beta2^2#
#
minus30.var <- sol.2D.minus30$mean.beta^4 + 6*(sol.2D.minus30$mean.beta^2)*sol.2D.minus30$var.beta +#
                 3*sol.2D.minus30$var.beta^2 - sol.2D.minus30$mean.beta2^2#
#
maxvarbeta2 <- 1.1 * max(sol.2D.minus20$var.beta2,sol.2D.minus30$var.beta2)#
#
plot(1:n.yrs,sol.2D.minus20$var.beta2,ylim=c(0,maxvarbeta2 ),col="blue",type="l",lwd=4,ylab="Variance of beta^2")#
points(1:n.yrs,minus20.var,col="red",type="l",lty=2)  # Gaussian approx #
#
points(1:n.yrs,sol.2D.minus30$var.beta2,col="turquoise",type="l",lwd=4)#
points(1:n.yrs,minus30.var,col="red",type="l",lty=2) # Gaussian approx #
add_panel_label("d")#
#
minus20.dvar <- 4*(sol.2D.minus20$mean.beta^2)*sol.2D.minus20$var.beta; #
minus30.dvar <- 4*(sol.2D.minus30$mean.beta^2)*sol.2D.minus30$var.beta; #
matpoints(1:n.yrs,cbind(minus20.dvar,minus30.dvar),type="l",lty=3,col="purple")#
legend("topright", c("Gaussian Approx","delta method"), lty=2,col=c("red","purple"),bty="n"); #
#
#the Gaussian assumption looks pretty good #
#
dev.new(); #
set_graph_pars("panel2"); #
plot(1:n.yrs,sol.2D.minus20$beta3,ylim=c(-1,1),col="turquoise",type="l",lwd=2,ylab="3rd central moment")#
points(1:n.yrs,sol.2D.minus30$beta3,col="blue",type="l",lwd=2)#
abline(h=0,col="red")#
#
plot(1:n.yrs,sol.2D.minus20$beta4-3*sol.2D.minus20$var.beta*sol.2D.minus20$var.beta,col="turquoise", type="l",lwd=2,ylab=" Deviation from Gaussian",ylim=c(-2,1))#
points(1:n.yrs,sol.2D.minus30$beta4-3*sol.2D.minus30$var.beta*sol.2D.minus30$var.beta,col="blue",type="l",lwd=2)#
abline(h=0,col="red")#
######################################################################################
# FOURTH PLOT: NEW VARIANCE APPROX#
######################################################################################
nBigMatrix <- nBigMatrix.z; #
#
#First Approximate mean with var from 2D IPM#
#
### params,init.mean.flow.int,n.iter,delta,var.beta.t,prop.Recr#
beta.minus20 <- Approx_dynamics_Mean(m.par.true,-20,n.yrs,0.00001,sol.2D.minus30$var.beta)#
beta.minus30 <- Approx_dynamics_Mean(m.par.true,-30,n.yrs,0.00001,sol.2D.minus30$var.beta)#
#
#quick test the skew term is really small#
year.test <- 20#
#
mean.beta <- sum(meshpts.beta20*beta20[,year.test ])#
var.beta <- sum((meshpts.beta20-mean.beta)^2*beta20[,year.test ])#
skew.beta <- sum((meshpts.beta20-mean.beta)^3*beta20[,year.test ])#
#
beta.minus20$dlam[year.test ] * var.beta#
beta.minus20$d2.lambda.d.beta2[year.test ] * skew.beta#
#
#it is as expected#
#
#quick check it all adds up - sum of terms in equ 28 (RHS) should equal lambda sensitivity#
set_graph_pars("panel2");#
#
sum.t <- beta.minus20$change.P.w+beta.minus20$change.F.w +beta.minus20$P.change.w+beta.minus20$F.change.w#
plot(beta.minus20$dlam,sum.t)#
#
cor.test(beta.minus20$dlam,sum.t)#
max(abs(beta.minus20$dlam-sum.t),na.rm=TRUE)#
#
sum.t <- beta.minus30$change.P.w+beta.minus30$change.F.w +beta.minus30$P.change.w+beta.minus30$F.change.w#
plot(beta.minus30$dlam,sum.t)#
#
cor.test(beta.minus30$dlam,sum.t)#
max(abs(beta.minus30$dlam-sum.t),na.rm=TRUE)#
#
#looks OK#
#
#plot mean approx (equ 18) against 2-dimensional IPM and IBM#
#
dev.new(height=4,width=8); ### start plot #
set_graph_pars("panel2"); #
matplot(mean.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
	ylab="Mean beta",xlim=c(1,n.yrs)) #
points(1:n.yrs,sol.2D.minus20$mean.beta,col="blue",type="l",lty=1,lwd=4)#
points(1:n.yrs,sol.2D.minus30$mean.beta,col="turquoise",type="l",lty=1,lwd=4)#
points(1:n.yrs,beta.minus20$beta.t.mean,col="red",type="l",lty=2,lwd=2)#
points(1:n.yrs,beta.minus30$beta.t.mean,col="red",type="l",lty=2,lwd=2)#
legend("topright",legend=c("IPM -20","IPM -30","Approx"),col=c("blue","turquoise","red"),#
    lty=1,bty="n",lwd=c(3,3,2));  #
#
add_panel_label("a")#
#
#plot 2-dimensional IPM variance and IBM#
#
matplot(var.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
	ylab="Variance beta",xlim=c(1,n.yrs))#
points(1:n.yrs,sol.2D.minus20$var.beta,col="blue",type="l",lwd=3)#
points(1:n.yrs,sol.2D.minus30$var.beta,col="turquoise",type="l",lwd=3)#
#
points(1:n.yrs,beta.minus20$beta.t.var,col="purple",type="l",lwd=2,lty=2)#
points(1:n.yrs,beta.minus30$beta.t.var,col="red",type="l",lwd=2,lty=2)#
add_panel_label("b")
dev.new(height=4,width=8); ### start plot #
set_graph_pars("panel2"); #
matplot(mean.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
	ylab="Mean beta",xlim=c(1,n.yrs)) #
points(1:n.yrs,sol.2D.minus20$mean.beta,col="blue",type="l",lty=1,lwd=4)#
points(1:n.yrs,sol.2D.minus30$mean.beta,col="turquoise",type="l",lty=1,lwd=4)#
points(1:n.yrs,beta.minus20$beta.t.mean,col="red",type="l",lty=2,lwd=2)#
points(1:n.yrs,beta.minus30$beta.t.mean,col="red",type="l",lty=2,lwd=2)#
legend("topright",legend=c("IPM -20","IPM -30","Approx"),col=c("blue","turquoise","red"),#
    lty=1,bty="n",lwd=c(3,3,2));  #
#
add_panel_label("a")#
#
#plot 2-dimensional IPM variance and IBM#
#
matplot(var.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
	ylab="Variance beta",xlim=c(1,n.yrs))#
points(1:n.yrs,sol.2D.minus20$var.beta,col="blue",type="l",lwd=3)#
points(1:n.yrs,sol.2D.minus30$var.beta,col="turquoise",type="l",lwd=3)#
#
points(1:n.yrs,beta.minus20$beta.t.var,col="purple",type="l",lwd=2,lty=2)#
points(1:n.yrs,beta.minus30$beta.t.var,col="red",type="l",lwd=2,lty=2)#
add_panel_label("b")
#plot recruitment - survival decompostion (equ 27)#
#
dev.new(height=4,width=8);#
set_graph_pars("panel2"); #
#
plot(1:n.yrs,beta.minus20$dlam,type="l",ylim=c(-0.02,0.03),lwd=2,xlab="Time",#
	ylab="Selection")#
points(1:n.yrs,beta.minus20$dsurv,col="red",type="l")#
points(1:n.yrs,beta.minus20$dfec,col="turquoise",type="l")#
abline(h=0)#
#
legend("topright",legend=c("Total","Surv","Rec"),col=c("black","red","turquoise"),#
    lty=1,bty="n",lwd=c(2,1,1),cex=0.75)#
add_panel_label("a")#
#
plot(1:n.yrs,beta.minus30$dlam,type="l",ylim=c(-0.02,0.03),lwd=2,xlab="Time",#
	ylab="Selection")#
points(1:n.yrs,beta.minus30$dsurv,col="red",type="l")#
points(1:n.yrs,beta.minus30$dfec,col="turquoise",type="l")#
abline(h=0)#
#
legend("topright",legend=c("Total","Surv","Rec"),col=c("black","red","turquoise"),#
    lty=1,bty="n",lwd=c(2,1,1),cex=0.75)#
add_panel_label("b")
#plot change in kernel and change in w terms from equ 28#
#
dev.new(height=4,width=8);#
set_graph_pars("panel2"); #
#
plot(1:n.yrs,beta.minus20$dlam,type="l",ylim=c(-0.15,0.15),lwd=2,xlab="Time",#
	ylab="Selection")#
points(1:n.yrs,beta.minus20$change.P.w+beta.minus20$change.F.w,col="red",type="l")#
points(1:n.yrs,beta.minus20$P.change.w+beta.minus20$F.change.w,col="turquoise",type="l")#
abline(h=0)#
add_panel_label("a")#
legend("topright",legend=c("Total",expression(partialdiff*(F+P)*w),expression((F+P)*partialdiff*w)),col=c("black","red","turquoise"),#
    lty=1,bty="n",lwd=c(2,1,1),cex=0.75)#
 plot(1:n.yrs,beta.minus30$dlam,type="l",ylim=c(-0.15,0.15),lwd=2,xlab="Time",#
	ylab="Selection")#
points(1:n.yrs,beta.minus30$change.P.w+beta.minus30$change.F.w,col="red",type="l")#
points(1:n.yrs,beta.minus30$P.change.w+beta.minus30$F.change.w,col="turquoise",type="l")#
abline(h=0)#
#
add_panel_label("b")#
#
legend("topright",legend=c("Total",expression(partialdiff*(F+P)*w),expression((F+P)*partialdiff*w)),col=c("black","red","turquoise"),#
    lty=1,bty="n",lwd=c(2,1,1),cex=0.75)
#plot all 4 terms from the decomposition equ 28   #
dev.new(height=4,width=8);#
set_graph_pars("panel2"); #
#
plot(1:n.yrs,beta.minus20$dlam,type="l",ylim=c(-0.15,0.2),lwd=2,xlab="Time",#
	ylab="Selection")#
points(1:n.yrs,beta.minus20$change.P.w,col="red",type="l",lwd=2)#
points(1:n.yrs,beta.minus20$change.F.w,col="turquoise",type="l",lwd=2)#
points(1:n.yrs,beta.minus20$P.change.w,col="red",type="l",lty=2)#
points(1:n.yrs,beta.minus20$F.change.w,col="turquoise",type="l",lty=2)#
abline(h=0)#
#
legend("topright", legend=c("Total",expression(partialdiff*P*w),expression(partialdiff*F*w),#
expression(P*partialdiff*w),expression(F*partialdiff*w)),col=c("black","red","turquoise","red","turquoise"),#
    lty=c(1,1,1,2,2),,bty="n",lwd=c(2,2,2,1,1),cex=0.5)#
#
add_panel_label("a")#
 plot(1:n.yrs,beta.minus30$dlam,type="l",ylim=c(-0.15,0.2),lwd=2,xlab="Time",#
	ylab="Selection")#
points(1:n.yrs,beta.minus30$change.P.w,col="red",type="l",lwd=2)#
points(1:n.yrs,beta.minus30$change.F.w,col="turquoise",type="l",lwd=2)#
points(1:n.yrs,beta.minus30$P.change.w,col="red",type="l",lty=2)#
points(1:n.yrs,beta.minus30$F.change.w,col="turquoise",type="l",lty=2)#
abline(h=0)#
#
legend("topright", legend=c("Total",expression(partialdiff*P*w),expression(partialdiff*F*w),#
expression(P*partialdiff*w),expression(F*partialdiff*w)),col=c("black","red","turquoise","red","turquoise"),#
    lty=c(1,1,1,2,2),bty="n",lwd=c(2,2,2,1,1),cex=0.5)#
#
add_panel_label("b")
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
## Use the Monocarp IBM with individual variation in flowering intercept to illustrate evolutionary dynamics#
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
#
rm(list=ls(all=TRUE))#
#
library(doBy)#
set.seed(53241986)#
#
## Working directory must be set here, so the source()'s below run#
setwd("~/Dropbox/Evol Demog/R code")#
#
source("Monocarp Demog Funs.R");#
source("Standard Graphical Pars.R");#
#
source("VarDynamics Funs.R"); #
#
# Set simulation parameters#
init.pop.size <- 10000#
Recr <- 7500#
#
n.yrs <- 500#
beta.off.sd <- 0.5#
init.beta.sd <- 0.7#
#
#  This generates the simulation data, it takes a while so we use #
#  a saved version#
load("SimData.Rdata")#
#
#load("SimDataSmallVar.Rdata")#
########### Run the IBM simulation #
if(FALSE) {#
  mean.flow.ints <- matrix(NA,nrow=n.yrs,ncol=10)#
  var.flow.ints <- matrix(NA,nrow=n.yrs,ncol=10)#
  min.z <- rep(NA,10)#
  max.z <- rep(NA,10)#
  min.beta <- rep(NA,10)#
  max.beta <- rep(NA,10)#
  for(reps in 1:10){#
     init.mean.flow.int <- ifelse(reps<6, -20, -30)#
	 source("Monocarp Simulate Evol IBM.R") #
     mean.flow.ints[,reps] <- mean.flow.int#
     var.flow.ints[,reps] <- var.flow.int#
     min.z[reps] <- min.z.t#
     max.z[reps] <- max.z.t#
     min.beta[reps] <- min.flow.int#
     max.beta[reps] <- max.flow.int#
     cat(reps,"   ",init.mean.flow.int,"\n")#
  }#
#
save(mean.flow.ints,var.flow.ints,min.z,max.z,min.beta,max.beta,#
n.yrs,beta.off.sd,init.beta.sd,file="SimData.Rdata")#
#
}#
########################################################################### #
# FIRST PLOT: IBM mean and variance of flowering intercept over time, 10 reps. #
############################################################################
#
graphics.off(); dev.new(); #
set_graph_pars("panel4"); #
matplot(mean.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
	ylab=expression(bar(beta)[0]),xlim=c(0,n.yrs))#
add_panel_label("a")#
matplot(var.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
ylab=expression("Var("* beta[0] *")"),xlim=c(0,n.yrs))#
add_panel_label("b")
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
## Use the Monocarp IBM with individual variation in flowering intercept to illustrate evolutionary dynamics#
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
#
rm(list=ls(all=TRUE))#
#
library(doBy)#
set.seed(53241986)#
#
## Working directory must be set here, so the source()'s below run#
root=ifelse(.Platform$OS.type=="windows","c:/repos","~/Repos"); #
setwd(paste(root,"/ipm_book/Rcode/c9",sep="")); #
#
source("../../Rcode/utilities/Standard Graphical Pars.R");#
#
source("../c2/Monocarp Demog Funs.R");#
# Set simulation parameters#
#
init.pop.size <- 10000#
Recr <- 7500#
n.yrs <-500#
beta.off.sd <- 0.5#
init.beta.sd <- 0.1#
#
#this generates the simulation data, it takes a while so we use #
#a saved version#
#
# # mean.flow.ints <- matrix(NA,nrow=n.yrs,ncol=10)#
# var.flow.ints <- matrix(NA,nrow=n.yrs,ncol=10)#
# min.z <- rep(NA,10)#
# max.z <- rep(NA,10)#
# min.beta <- rep(NA,10)#
# max.beta <- rep(NA,10)#
#
# for(reps in 1:10){#
	# init.mean.flow.int <- ifelse(reps<6, -20, -30)#
	# source("Monocarp Simulate Evol IBM.R") #
    # mean.flow.ints[,reps] <- mean.flow.int#
    # var.flow.ints[,reps] <- var.flow.int#
    # min.z[reps] <- min.z.t#
    # max.z[reps] <- max.z.t#
    # min.beta[reps] <- min.flow.int#
    # max.beta[reps] <- max.flow.int#
    # cat(reps,"   ",init.mean.flow.int,"\n")#
# }#
#
#save(mean.flow.ints,var.flow.ints,min.z,max.z,min.beta,max.beta,file="SimData.Rdata")#
# save(mean.flow.ints,var.flow.ints,beta.off.sd,init.beta.sd,n.yrs,file="SimDataSmallVar.Rdata")#
#
load("SimData.Rdata")#
#
dev.new(height=4,width=8);#
set_graph_pars("panel2"); #
matplot(mean.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",ylab=expression(bar(beta)[0]))#
add_panel_label("a")#
matplot(var.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",ylab=expression("Var("* beta[0] *")"))#
add_panel_label("b")#
#
#dev.copy2eps(file="~/Repos/ipm_book/c9/figures/OenotheraIBMevol.eps")#
#
#Implement a 2-dimensional IPM #
iterate_model <- function(params,n.iter,init.beta.mean,init.beta.sd,meshpts.beta,meshpts.z) {#
#
    nt <- matrix(NA,nrow=nBigMatrix.z,ncol=nBigMatrix.beta)#
    z.s <- dnorm(meshpts.z, mean = 2.9, sd = m.par.true["rcsz.sd"])#
    flow.int.s <- dnorm(meshpts.beta, mean = init.beta.mean, sd = init.beta.sd)#
    nt <- init.pop.size*matrix(outer(z.s,flow.int.s),nrow=nBigMatrix.z)#
	## Matrix to store distribution of flowering intercepts #
	nBeta <- length(meshpts.beta);#
	betaDist <- matrix(0, nBeta,n.iter)#
	betaDist[,1] = apply(nt,2,sum); betaDist[,1]=betaDist[,1]/sum(betaDist[,1])#
	#array of P matrices for each beta#
    P.beta <- array(NA,c(nBigMatrix.beta,nBigMatrix.z,nBigMatrix.z))#
#
	#array to store #
    Seeds.beta <- array(NA,c(nBigMatrix.beta,nBigMatrix.z))#
#
	#Number of seeds by a size z plant#
    Seeds_z <- function ( z, m.par) {#
            return( p_bz(z, m.par) * b_z(z, m.par) )#
     }#
#
	for(i in 1:nBigMatrix.beta){#
		params["flow.int"] <- meshpts.beta[i]#
		P.beta[i,1:nBigMatrix.z,1:nBigMatrix.z] <- h.z * (outer(meshpts.z, meshpts.z, P_z1z, m.par = 			params))#
		Seeds.beta[i,1:nBigMatrix.z] <- Seeds_z(meshpts.z, params)#
	}#
#
	#Inheritance kernel#
	M <- matrix(NA,ncol=nBigMatrix.beta,nrow=nBigMatrix.beta)#
	for(i in 1:nBigMatrix.beta){#
 		 M[,i] <- dnorm(meshpts.beta,mean=meshpts.beta[i],sd=beta.off.sd)#
  	}#
#
	#pdf of offspring sizes#
	off.pdf <- c_0z1(meshpts.z,m.par.true)#
	beta2 <- meshpts.beta*meshpts.beta#
	mean.beta <- rep(NA,n.iter)#
	mean.beta[1] <- init.beta.mean#
	var.beta <- rep(NA,n.iter)#
	var.beta[1] <- init.beta.sd*init.beta.sd#
	prop.Recr <- rep(NA,n.iter)#
	mean.beta2 <- rep(NA,n.iter)#
	mean.beta2[1] <- sum(flow.int.s*beta2)/sum(flow.int.s)#
	var.beta2 <- rep(NA,n.iter);#
	########### Compute var(beta2) using formula Var=E[(X-Xbar)^2], not Var=E[X^2]-E[X]^2. #
	beta2Dev <- beta2-mean.beta2[1]; #
	var.beta2[1] <- sum(flow.int.s*beta2Dev^2)/sum(flow.int.s)#
	index <- 1:nBigMatrix.beta#
	#Iterate the model#
	for(gen in 2:n.iter){#
	#calculate seeds produced by beta_i plants#
	seeds.from.betai <- sapply(index,function(i) h.z*sum(Seeds.beta[i,] %*% nt[,i]))#
#
	#redistribute seeds according to inheritance kernel#
	seeds.with.betai <- h.beta * (M %*% seeds.from.betai)#
#
	f.recruits.with.betai <- seeds.with.betai/sum(seeds.from.betai)#
#
	nt1 <- sapply(index,function(i) P.beta[i,,] %*% nt[,i] + Recr * off.pdf * f.recruits.with.betai[i])#
#
	n.surv <- sapply(index,function(i) P.beta[i,,] %*% nt[,i])#
	n.surv <- sum(n.surv) * h.z * h.beta#
	nt <- nt1#
	prop.Recr[gen] <- Recr/(Recr+n.surv)#
	betaDist[,gen] = apply(nt,2,sum); betaDist[,gen] <- betaDist[,gen]/sum(betaDist[,gen]); #
	betaFreq <- betaDist[,gen] #
	#### Compute variances of beta and beta^2 using formula Var=E[(X-Xbar)^2] #
	mean.beta[gen] <- sum(betaFreq*meshpts.beta); #
	betaDev <- meshpts.beta - mean.beta[gen];#
	var.beta[gen] <- sum(betaFreq*betaDev^2); #
	mean.beta2[gen] <- sum(betaFreq*beta2); #beta2 = meshpts.beta^2 #
	beta2Dev <- beta2 - mean.beta2[gen] #
	var.beta2[gen] <- sum(betaFreq*beta2Dev^2); #
	if(gen%%10==0) cat(gen,"  ",mean.beta[gen],"   ",Recr/(Recr+n.surv),"\n")#
}#
return(list(mean.beta=mean.beta,var.beta=var.beta,mean.beta2=mean.beta2,var.beta2=var.beta2,#
			prop.Recr=prop.Recr,nt=nt,betaDist=betaDist))#
}#
#
nBigMatrix.z <- 100; #
nBigMatrix.beta <- 100; #
#
#######################  solve beta(0) = -20 first#
U.beta <- max(max.beta[1:5]) +  1 #
L.beta <-  min(min.beta[1:5]) - 1#
h.beta <- (U.beta - L.beta)/nBigMatrix.beta #
meshpts.beta <- L.beta + ((1:nBigMatrix.beta) - 1/2) * h.beta#
#
U.z <- max(max.z[1:5]) + 0.5 #
L.z <- min(min.z[1:5]) - 0.5 #
h.z <- (U.z - L.z)/nBigMatrix.z#
meshpts.z <- L.z + ((1:nBigMatrix.z) - 1/2) * h.z#
#
sol.2D.minus20 <- iterate_model(m.par.true,n.yrs,-20,init.beta.sd,meshpts.beta,meshpts.z)#
#
########################   solve beta(0) = -30 next#
U.beta <- max(max.beta[6:10]) +  1 #
L.beta <-  min(min.beta[6:10]) - 1#
h.beta <- (U.beta - L.beta)/nBigMatrix.beta #
meshpts.beta <- L.beta + ((1:nBigMatrix.beta) - 1/2) * h.beta#
#
U.z <- max(max.z[6:10]) + 0.5 #
L.z <- min(min.z[6:10]) - 0.5 #
h.z <- (U.z - L.z)/nBigMatrix.z#
meshpts.z <- L.z + ((1:nBigMatrix.z) - 1/2) * h.z#
sol.2D.minus30 <- iterate_model(m.par.true,n.yrs,-30,init.beta.sd,meshpts.beta,meshpts.z)#
#
dev.new(height=6,width=8);#
#
set_graph_pars("panel4"); #
matplot(mean.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",ylab=expression(bar(beta)[0]))#
points(1:n.yrs,sol.2D.minus20$mean.beta,col="blue",type="l",lwd=4)#
points(1:n.yrs,sol.2D.minus30$mean.beta,col="turquoise",type="l",lwd=4)#
#abline(h=-24.92462,col="red")#
add_panel_label("a")#
#
legend("topright",legend=c("IPM -20","IPM -30"),col=c("blue","turquoise"),#
    lty=1,bty="n",lwd=c(3,3));  #
matplot(,var.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",ylab=expression("Var("* beta[0] *")"))#
points(1:n.yrs,sol.2D.minus20$var.beta,col="blue",type="l",lwd=4)#
points(1:n.yrs,sol.2D.minus30$var.beta,col="turquoise",type="l",lwd=4)#
add_panel_label("b")#
#
## plot beta distributions over time #
beta20 <- sol.2D.minus20$betaDist;#
matplot(meshpts.beta,beta20[,c(1,100,300,500)], xlab="Beta", ylab="Relative Frequency",type="l"); #
#
beta30 <- sol.2D.minus30$betaDist;#
matplot(meshpts.beta,beta30[,c(1,100,300,500)], xlab="Beta", ylab="Relative Frequency",type="l"); #
####################################################################################################
#Approximate dynamics using Iwasa et al. 1991 Evolution#
#####################################################################################################
#
R0_calc <- function (params) {#
	IPM.true <- mk_K(nBigMatrix, params, L.z, U.z)#
	# to keep close to the formulae in the text next we define the F and P iteration matricies#
    P <- IPM.true$P;  F <- IPM.true$F;#
#
    # Fundamental operator #
     N <- solve(diag(nBigMatrix)-P); #
#
    # Compute R0 as dominant eigenvalue of FN#
    R <- F %*% N#
    R0 <- abs(eigen(R)$values[1])#
    return(R0)#
}#
Approx_dynamics <- function(params,init.mean.flow.int,n.iter,delta,var.beta.t) {#
	params["flow.int"]<- init.mean.flow.int#
	beta.t.mean <- rep(NA,n.iter)#
	beta.t.mean[1] <- init.mean.flow.int#
for(gen in 2:n.iter){#
#
#Calculate p.r so the current mean strategy is at equilibrium lambda=1#
	params["p.r"] <- 1#
	equ.p.r <- 1/R0_calc(params)#
	params["p.r"] <- equ.p.r#
#
#Calculate the derivative of lambda with respect to beta#
	params["flow.int"] <- params["flow.int"] + delta#
	IPM.kernel <- mk_K(nBigMatrix, params, L.z, U.z)#
	lambda.up <- Re(eigen(IPM.kernel$K,only.values = TRUE)$values[1])#
	params["flow.int"] <- params["flow.int"] - delta#
	params["flow.int"] <- params["flow.int"] - delta#
	IPM.kernel <- mk_K(nBigMatrix, params, L.z, U.z)#
	lambda.down <- Re(eigen(IPM.kernel$K,only.values = TRUE)$values[1])#
	params["flow.int"] <- params["flow.int"] + delta#
#
	d.lambda.d.beta <- (lambda.up - lambda.down)/(2*delta)#
#
#Calculate the mean intercept#
	beta.t.mean[gen] <- beta.t.mean[gen-1] + d.lambda.d.beta * var.beta.t[gen-1]#
	params["flow.int"] <- beta.t.mean[gen]#
	if(gen%%10==0) cat(gen,"  ",beta.t.mean[gen],"  ",d.lambda.d.beta,"\n")#
}#
#
return(beta.t.mean)#
}#
#
nBigMatrix <- nBigMatrix.z; #
#
beta.minus20 <- Approx_dynamics(m.par.true,-20,n.yrs,.Machine$double.eps^(1/3),sol.2D.minus20$var.beta)#
beta.minus30 <- Approx_dynamics(m.par.true,-30,n.yrs,.Machine$double.eps^(1/3),sol.2D.minus30$var.beta)#
#
dev.new(height=4,width=8);#
#
set_graph_pars("panel2"); #
matplot(mean.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
	ylab=expression(bar(beta)[0]),xlim=c(1,n.yrs)) #
points(1:n.yrs,sol.2D.minus20$mean.beta,col="blue",type="l",lty=1,lwd=4)#
points(1:n.yrs,sol.2D.minus30$mean.beta,col="turquoise",type="l",lty=1,lwd=4)#
points(1:n.yrs,beta.minus20,col="red",type="l",lty=2,lwd=2)#
points(1:n.yrs,beta.minus30,col="red",type="l",lty=2,lwd=2)#
legend("topright",legend=c("IPM -20","IPM -30","Approx"),col=c("blue","turquoise","red"),#
    lty=1,bty="n",lwd=c(3,3,2));  #
#
add_panel_label("a")#
#
matplot(var.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",#
ylab=expression("Var("* beta[0] *")"),,xlim=c(0,n.yrs))#
points(1:n.yrs,sol.2D.minus20$var.beta,col="blue",type="l",lwd=4)#
points(1:n.yrs,sol.2D.minus30$var.beta,col="turquoise",type="l",lwd=4)#
add_panel_label("b")
dev.copy2eps(file="~/Repos/ipm_book/c9/figures/OenotheraIBMevolPreds.eps")
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
## Use the Monocarp IBM with individual variation in flowering intercept to illustrate evolutionary dynamics#
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
#
rm(list=ls(all=TRUE))#
#
library(doBy)#
set.seed(53241986)#
#
## Working directory must be set here, so the source()'s below run#
root=ifelse(.Platform$OS.type=="windows","c:/repos","~/Repos"); #
setwd(paste(root,"/ipm_book/Rcode/c9",sep="")); #
#
source("../../Rcode/utilities/Standard Graphical Pars.R");#
#
source("../c2/Monocarp Demog Funs.R");#
# Set simulation parameters#
#
init.pop.size <- 10000#
Recr <- 7500#
n.yrs <-500#
beta.off.sd <- 0.5#
init.beta.sd <- 0.1#
#
#this generates the simulation data, it takes a while so we use #
#a saved version#
#
# # mean.flow.ints <- matrix(NA,nrow=n.yrs,ncol=10)#
# var.flow.ints <- matrix(NA,nrow=n.yrs,ncol=10)#
# min.z <- rep(NA,10)#
# max.z <- rep(NA,10)#
# min.beta <- rep(NA,10)#
# max.beta <- rep(NA,10)#
#
# for(reps in 1:10){#
	# init.mean.flow.int <- ifelse(reps<6, -20, -30)#
	# source("Monocarp Simulate Evol IBM.R") #
    # mean.flow.ints[,reps] <- mean.flow.int#
    # var.flow.ints[,reps] <- var.flow.int#
    # min.z[reps] <- min.z.t#
    # max.z[reps] <- max.z.t#
    # min.beta[reps] <- min.flow.int#
    # max.beta[reps] <- max.flow.int#
    # cat(reps,"   ",init.mean.flow.int,"\n")#
# }#
#
#save(mean.flow.ints,var.flow.ints,min.z,max.z,min.beta,max.beta,file="SimData.Rdata")#
# save(mean.flow.ints,var.flow.ints,beta.off.sd,init.beta.sd,n.yrs,file="SimDataSmallVar.Rdata")#
#
load("SimData.Rdata")#
#
dev.new(height=4,width=8);#
set_graph_pars("panel2"); #
matplot(mean.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",ylab=expression(bar(beta)[0]))#
add_panel_label("a")#
matplot(var.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",ylab=expression("Var("* beta[0] *")"))#
add_panel_label("b")
dev.copy2eps(file="~/Repos/ipm_book/c9/figures/OenotheraIBMevol.eps")
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
## Use the Carlina IBM with individual variation in flowering intercept to illustrate evolutionary dynamics in a #
## stochastic environment#
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
rm(list=ls(all=TRUE))#
#
library(doBy)#
set.seed(53241986)#
#
## Working directory must be set here, so the source()'s below run#
root=ifelse(.Platform$OS.type=="windows","c:/repos","~/Repos"); #
setwd(paste(root,"/ipm_book/Rcode/c9",sep="")); #
#
source("../utilities/Standard Graphical Pars.R");#
source("Carlina Demog Funs.R");#
#
########################################################################################################
#  Simulate IBM with flowering intercept variation #
########################################################################################################
# Set simulation parameters#
init.pop.size <- 10000#
init.mean.z <- 3#
init.sd.z <- 2#
n.yrs <-500#
beta.off.sd <- 0.5#
init.beta.sd <- 0.7#
#Rec.mult multiples the actual number of recruits observed so we have a large population#
Rec.mult <- 500#
#
# this generates the simulation data, it takes a while so we use #
# a saved version - also note that the combination of demographic and #
# environmental stochasticity leads to err.... extinction at times.#
#
mean.flow.ints <- matrix(NA,nrow=n.yrs,ncol=10)#
var.flow.ints <- matrix(NA,nrow=n.yrs,ncol=10)#
min.z <- rep(NA,10)#
max.z <- rep(NA,10)#
min.beta <- rep(NA,10)#
max.beta <- rep(NA,10)#
#
for(reps in 1:10){#
	init.mean.flow.int <- ifelse(reps<6, -22, -5)#
	source("Carlina Simulate Evol IBM.R") #
    mean.flow.ints[,reps] <- mean.flow.int#
    var.flow.ints[,reps] <- var.flow.int#
    min.z[reps] <- min.z.t#
    max.z[reps] <- max.z.t#
    min.beta[reps] <- min.flow.int#
    max.beta[reps] <- max.flow.int#
    cat(reps,"   ",init.mean.flow.int,"\n")#
}#
# save(mean.flow.ints,var.flow.ints,min.z,max.z,min.beta,max.beta,file="SimDataStoc.Rdata")#
#
load("SimDataStoc.Rdata")#
dev.new(height=4,width=8);#
set_graph_pars("panel2"); #
matplot(mean.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",ylab=expression(bar(beta)[0]))#
add_panel_label("a")#
#Add ESS#
abline(h= -14.34,col="red", lwd=2)#
#Add simulation mean after the 1st 100 years#
abline(h= mean(mean.flow.ints[100:500,],na.rm=TRUE),col="turquoise", lwd=2)#
#
matplot(var.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",ylab=expression("Var("* beta[0] *")"))#
add_panel_label("b")#
#
#dev.copy2eps(file="~/Repos/ipm_book/c9/figures/CarlinaStocIBM.eps")#
#
########################################################################################### #
# Simulate the 2-dimensional IPM with (size x intercept) structure #
############################################################################################
m.par.sim <- m.par.true#
#set mean flow.int <- 0 as each individual has it's own beta_0 and so this is the yearly deviation#
m.par.sim["flow.int"] <- 0#
#
nBigMatrix.z <- 60; #
nBigMatrix.beta <- 50; #
#
#######################  solve first for beta(0) = -5#
U.beta <- max(max.beta[1:5]) +  1 #
L.beta <-  min(min.beta[1:5]) - 1#
h.beta <- (U.beta - L.beta)/nBigMatrix.beta #
meshpts.beta <- L.beta + ((1:nBigMatrix.beta) - 1/2) * h.beta#
#
U.z <- max(max.z[1:5]) + 0.5 #
L.z <- min(min.z[1:5]) - 0.5 #
h.z <- (U.z - L.z)/nBigMatrix.z#
meshpts.z <- L.z + ((1:nBigMatrix.z) - 1/2) * h.z#
#
source("Carlina Simulate Evol IPM.R") # creates function to simulate the IPM #
sol.2D.minus20 <- iterate_model(m.par.true,n.yrs,-5,init.beta.sd,meshpts.beta,meshpts.z)#
#
########################   solve beta(0) = -22 next#
U.beta <- max(max.beta[6:10]) +  1 #
L.beta <-  min(min.beta[6:10]) - 1#
h.beta <- (U.beta - L.beta)/nBigMatrix.beta #
meshpts.beta <- L.beta + ((1:nBigMatrix.beta) - 1/2) * h.beta#
#
U.z <- max(max.z[6:10]) + 0.5 #
L.z <- min(min.z[6:10]) - 0.5 #
h.z <- (U.z - L.z)/nBigMatrix.z#
meshpts.z <- L.z + ((1:nBigMatrix.z) - 1/2) * h.z#
#
sol.2D.minus30 <- iterate_model(m.par.true,n.yrs,-22,init.beta.sd,meshpts.beta,meshpts.z)#
#
#### Plot the results #
#
dev.new(height=4,width=8);#
set_graph_pars("panel2"); #
matplot(mean.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",ylab=expression(bar(beta)[0]))#
points(1:n.yrs,sol.2D.minus20$mean.beta,col="green",type="l")#
points(1:n.yrs,sol.2D.minus30$mean.beta,col="blue",type="l")#
abline(h=-14.34,col="red")#
abline(h= mean(mean.flow.ints[100:500,],na.rm=TRUE),col="turquoise")#
#
add_panel_label("a")#
#
matplot(,var.flow.ints,type="l",col=rep(c("black","grey"),rep(5,2)),xlab="Time",ylab=expression("Var("* beta[0] *")"))#
points(1:n.yrs,sol.2D.minus20$var.beta,col="green",type="l")#
points(1:n.yrs,sol.2D.minus30$var.beta,col="blue",type="l")#
add_panel_label("b")
dev.copy2eps(file="~/Repos/ipm_book/c9/figures/CarlinaStocIBM.eps")
